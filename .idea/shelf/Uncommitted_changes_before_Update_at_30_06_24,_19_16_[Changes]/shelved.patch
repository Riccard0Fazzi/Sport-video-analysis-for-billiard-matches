Index: src/ball_detection_blob.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/ball_detection_blob.cpp b/src/ball_detection_blob.cpp
new file mode 100644
--- /dev/null	(date 1719761543015)
+++ b/src/ball_detection_blob.cpp	(date 1719761543015)
@@ -0,0 +1,145 @@
+// Created by Tommaso Tubaldo on 06/06/24 - Hours: --
+#include <iostream>
+#include <opencv2/opencv.hpp>
+
+using namespace cv;
+
+int main(int argc, char** argv) {
+    if (argc < 3) {
+        std :: cout << "An image file and a image name with folder path should be provided!";
+        return EXIT_FAILURE;
+    }   // Checks for the correctness of the input values
+
+    Mat img = imread(argv[1]);
+    if (img.empty()) {
+        std :: cout << "The image cannot be read!";
+        return EXIT_FAILURE;
+    }   // Check for the validity of the input image
+
+    // Bilateral Filter after-conversion
+    Mat filtered_gray_img;
+    bilateralFilter(img,filtered_gray_img,7,90,300);
+
+    std::string output_img_name13 = "/bilateralFilter.png";
+    imwrite(argv[2]+output_img_name13,filtered_gray_img);
+
+    // HSV conversion
+    Mat hsv_img;
+    cvtColor(filtered_gray_img, hsv_img, COLOR_BGR2HSV_FULL);
+
+    // TABLE SEGMENTATION
+    // Create a histogram with 30 bins for Hue, 32 bins for Saturation, and 32 bins for Value
+    int hBins = 30, sBins = 32, vBins = 32;
+    int histSize[] = {hBins, sBins, vBins};
+
+    // Hue varies from 0 to 179, Saturation and Value from 0 to 255
+    float h_range[] = {0, 180};
+    float s_range[] = {0, 256};
+    float v_range[] = {0, 256};
+    const float* ranges[] = {h_range, s_range, v_range};
+
+    // Use the 0-th, 1-st, and 2-nd channels
+    int channels[] = {0, 1, 2};
+
+    Mat hist;
+    calcHist(&hsv_img,1,channels,Mat(),hist,3,histSize,ranges);
+
+    // Find the bin with the maximum count
+    double maxVal = 0;
+    int maxIdx[3] = {0, 0, 0};
+    minMaxIdx(hist, nullptr, &maxVal, nullptr, maxIdx);
+
+    // Convert the bin index to HSV color
+    int hBin = maxIdx[0], sBin = maxIdx[1], vBin = maxIdx[2];
+    float hStep = 180.0f / hBins, sStep = 256.0f / sBins, vStep = 256.0f / vBins;
+    Vec3b mostCommonColorHSV(hBin * hStep, sBin * sStep, vBin * vStep);
+
+    // Create a mask for the most common color
+    int h_thresh = 70;
+    int s_thresh = 50;
+    int v_thresh = 50;
+    Scalar lowerBound(mostCommonColorHSV[0] - h_thresh, mostCommonColorHSV[1]-s_thresh, mostCommonColorHSV[2]-v_thresh);
+    Scalar upperBound(mostCommonColorHSV[0] + h_thresh, mostCommonColorHSV[1]+s_thresh, mostCommonColorHSV[2]+v_thresh);
+    Mat mask;
+    inRange(hsv_img, lowerBound, upperBound, mask);
+
+    // Invert the mask to remove the most common color
+    cv::Mat invertedMask;
+    cv::bitwise_not(mask, invertedMask);
+
+    std::string output_img_name11 = "/mask.png";
+    imwrite(argv[2]+output_img_name11,invertedMask);
+
+    // Apply the mask to the original image
+    cv::Mat result;
+    img.copyTo(result, invertedMask);
+
+    std::string output_img_name8 = "/mask.png";
+    imwrite(argv[2]+output_img_name8,result);
+
+    std::vector<Mat> res_channels;
+    split(result,res_channels);
+    threshold(res_channels[0],result,0,255,THRESH_BINARY);
+
+    std::string output_img_name9 = "/mask_binary.png";
+    imwrite(argv[2]+output_img_name9,result);
+
+    // Apply erosion to the mask
+    erode(result,result,getStructuringElement(MORPH_ELLIPSE,Size(3,3)),Point(-1,-1),5);
+    std::string output_img_name4 = "/eroded_mask.png";
+    imwrite(argv[2]+output_img_name4,result);
+
+    dilate(result,result,getStructuringElement(MORPH_ELLIPSE,Size(3,3)),Point(-1,-1),5);
+    // morphologyEx(result,result,MORPH_OPEN,getStructuringElement(MORPH_CROSS,Size(2,2)));
+
+    std::string output_img_name3 = "/opened_mask.png";
+    imwrite(argv[2]+output_img_name3,result);
+
+    // Setup SimpleBlobDetector parameters
+    SimpleBlobDetector::Params params;
+    // Change thresholds
+    params.minThreshold = 0;
+    params.maxThreshold = 255;
+    // Filter by Area.
+    params.filterByArea = true;
+    params.minArea = 100;
+    params.maxArea = 1000;
+    // Filter by Circularity
+    params.filterByCircularity = true;
+    params.minCircularity = 0.5;
+    params.maxCircularity = 1;
+    // Filter by Convexity
+    params.filterByConvexity = false;
+    params.minConvexity = 0.5;
+    params.maxConvexity = 1;
+    // Filter by Inertia
+    params.filterByInertia = false;
+    params.minInertiaRatio = 0.02;
+    params.maxInertiaRatio = 1;
+    // Minimum distance between blobs
+    params.minDistBetweenBlobs = static_cast<float>(result.rows)/40;
+    params.blobColor = 255;
+    params.thresholdStep = 254;
+
+    // Storage for blobs
+    std::vector<KeyPoint> keypoints;
+
+    // Set up detector with params
+    Ptr<SimpleBlobDetector> detector = SimpleBlobDetector::create(params);
+
+    // Detect blobs
+    detector->detect(result, keypoints);
+
+    // Draw detected blobs as red circles.
+    // DrawMatchesFlags::DRAW_RICH_KEYPOINTS flag ensures
+    // the size of the circle corresponds to the size of blob
+
+    Mat img_with_keypoints;
+    drawKeypoints(img, keypoints, img_with_keypoints, Scalar(0, 0, 255), DrawMatchesFlags::DRAW_RICH_KEYPOINTS);
+
+
+    std::string output_img_name2 = "/blobs.png";
+    imwrite(argv[2]+output_img_name2,img_with_keypoints);  // Saving the image on the desired folder
+
+    return 0;
+}
\ No newline at end of file
